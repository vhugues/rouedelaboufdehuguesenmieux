<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>üçΩÔ∏è La Roue de la bouf</title>
  <style>
    :root {
      --bg-gradient: linear-gradient(135deg, #f8b500, #ec6f66);
      --card-bg: rgba(255, 255, 255, 0.2);
      --modal-bg: linear-gradient(135deg, #b38300, #b62116);
      --text-color: #fff;
      --accent: #fff176;
      --shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
    }

    * {
      box-sizing: border-box;
      font-family: "Poppins", sans-serif;
    }

    body {
      margin: 0;
      padding: 0;
      background: var(--bg-gradient);
      color: var(--text-color);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100vh;
    }

    h1 {
      margin-top: 20px;
      font-size: 2rem;
      text-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    }

    #controls {
      margin-top: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
    }

    label {
      font-size: 0.9rem;
    }

    input[type="number"],
    input[type="text"] {
      border: none;
      border-radius: 6px;
      padding: 5px 8px;
      outline: none;
    }

    input[type="color"] {
      border: none;
      background: transparent;
      cursor: pointer;
    }

    button {
      background: rgba(255, 255, 255, 0.25);
      border: none;
      border-radius: 10px;
      padding: 8px 14px;
      cursor: pointer;
      color: var(--text-color);
      transition: all 0.2s;
      box-shadow: var(--shadow);
    }

    button:hover {
      background: var(--accent);
      color: #222;
      transform: scale(1.05);
    }

    #inputs {
      width: 90%;
      max-width: 600px;
      margin-top: 20px;
      margin-bottom: 20px;
      background: var(--card-bg);
      border-radius: 12px;
      padding: 10px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(5px);
    }

    #inputs div {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin: 5px 0;
      padding: 5px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.1);
    }

    #canvas-container {
      position: relative;
      text-align: center;
      margin-top: 30px;
    }

    canvas {
      transition: transform ease-out;
      border-radius: 50%;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
    }

    .trait {
      position: absolute;
      top: -20px;
      left: 50%;
      width: 4px;
      height: 40px;
      background: #fff;
      transform: translateX(-50%);
      border-radius: 2px;
      z-index: 10;
    }

    #winner {
      font-size: 1.5rem;
      font-weight: bold;
      margin-top: 20px;
      text-align: center;
      opacity: 0;
      transform: scale(0.8);
      transition: all 0.4s ease;
    }

    #winner.show {
      opacity: 1;
      transform: scale(1);
    }
    
    /* --- Modal CSS --- */
    #modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    #modal-content {
      background: var(--modal-bg); /* Use card background */
      color: var(--text-color);
      padding: 20px;
      border-radius: 12px;
      box-shadow: var(--shadow);
      max-width: 90%;
      max-height: 90%;
      overflow-y: auto;
      width: 800px;
      max-width: 95vw;
      position: relative;
      backdrop-filter: blur(10px); /* Apply blur effect */
    }
	
    #modal-close {
		position: absolute;
		display: block;
		top: 0;
		right: 0;
		color: transparent;
		text-shadow: 0 0 #ffffff;
		padding: 10px;
		cursor: pointer;
		opacity: 0.5;
		transition-duration: 0.2s;
	}

    #modal-content h2 {
      margin-top: 0;
      border-bottom: 2px solid rgba(255, 255, 255, 0.3); /* Lighter divider */
      padding-bottom: 10px;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    }

    #vote-config-content {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    #vote-config-content label {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    #vote-config-content input {
      padding: 8px;
      border: none;
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.8);
      color: #333;
    }

    .plat-vote-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      padding: 10px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.15); /* Light glass effect */
      box-shadow: 0 1px 5px rgba(0, 0, 0, 0.1);
	  border-left: solid 6px;
    }

    .vote-controls button {
      padding: 5px 10px;
      margin: 0 5px;
      font-size: 1.1rem;
      color: var(--text-color);
      box-shadow: none;
      background: #d04a11;
      border: 1px solid #b5400f;
      text-shadow: 0px 0 #97360c;
      color: transparent;
    }
    .vote-controls button.limit {
      opacity:0.2;
    }

    .vote-controls button:not(.limit):hover {
      background: #c64710;
      text-shadow: 0px 0 #5e2208;
      border-color: #5e2208;
    }
    .vote-controls span {
		font-size: 20px;
		font-weight: bold;
		line-height: 1em;
		min-width: 20px;
		display: inline-block;
		text-align: center;
		margin: 0 0px;
	}
	
    .vote-info {
        font-size: 0.9em;
    }

    #modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 20px;
    }

    #modal-footer button {
      background: #4CAF50; /* Green */
      color: white;
      padding: 10px 15px;
      border: none;
      border-radius: 6px;
      box-shadow: var(--shadow);
    }
    
    #modal-footer button#next-participant {
      background: #2196F3; /* Blue */
    }
    
    #modal-footer button:hover {
        transform: scale(1.05);
    }

    @media (max-width: 600px) {
      canvas {
        width: 300px !important;
        height: 300px !important;
      }
      #controls {
        flex-direction: column;
        align-items: center;
      }
    }
  </style>
</head>
<body>
  <h1>üçΩÔ∏è La Roue de la bouf</h1>

  <div class="controls">
    <label>Dur√©e (s) <input id="duration" type="number" min="1" value="15"></label>
    <label>Tours min <input id="nbTour" type="number" min="1" value="10"></label>
  </div>

  <div id="inputs"></div>
  <div class="controls">
    <button id="add">+ Ajouter</button>
    <button id="start">üéØ Tourner</button>
    <button id="start-vote">Lancer un vote</button>
	</div>

  <div id="canvas-container">
    <div class="trait"></div>
    <canvas id="canvas" width="500" height="500"></canvas>
  </div>

  <div id="winner"></div>

  <div id="modal-overlay">
    <div id="modal-content">
      <div id="modal-close">‚ùå</div>
      <h2 id="modal-title"></h2>
      <div id="modal-body">
        </div>
      <div id="modal-footer">
        </div>
    </div>
  </div>

  <script>
    const duration = document.getElementById("duration");
    const nbTour = document.getElementById("nbTour");
    const addBtn = document.getElementById("add");
    const startBtn = document.getElementById("start");
    const inputs = document.getElementById("inputs");
    const winner = document.getElementById("winner");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    
    // New elements for the voting feature
    const startVoteBtn = document.getElementById("start-vote");
    const modalOverlay = document.getElementById("modal-overlay");
    const modalTitle = document.getElementById("modal-title");
    const modalBody = document.getElementById("modal-body");
    const modalFooter = document.getElementById("modal-footer");
    
    let lastAngle = 0;
    let choices = [];
    
    // Voting State
    let votesPerParticipant = 3; // Default value
    let currentParticipant = 1;
    let participantVotes = {}; // Stores all votes: { participant_id: { choice_id: score } }

    function randomColor() {
      return "#" + Math.floor(Math.random() * 16777215).toString(16).padStart(6, "0");
    }

    // --- Local Storage Management ---
    function saveConfig() {
        localStorage.setItem("duration", duration.value);
        localStorage.setItem("nbTour", nbTour.value);
        localStorage.setItem("votesPerParticipant", votesPerParticipant);
    }

    function loadConfig() {
        duration.value = localStorage.getItem("duration") || 15;
        nbTour.value = localStorage.getItem("nbTour") || 10;
        votesPerParticipant = Number(localStorage.getItem("votesPerParticipant")) || 10;
    }
    
    function saveChoices() {
      // Save choices, including their ID and their original weight
      localStorage.setItem("choices", JSON.stringify(choices));
    }

    function loadChoices() {
      const stored = localStorage.getItem("choices");
      const loadedChoices = stored ? JSON.parse(stored) : [];
      // Ensure each choice has a unique ID and a default weight
      loadedChoices.forEach(c => {
          if (!c.id) c.id = Date.now() + Math.random();
          // weight is the base weight before score adjustment
          if (!c.weight) c.weight = 0; 
      });
      return loadedChoices;
    }

    // --- Weight Calculation (New) ---
    function calculateTotalScore(choiceId) {
        let totalScore = 0;
        for (const p in participantVotes) {
            totalScore += participantVotes[p][choiceId] || 0;
        }
        return totalScore;
    }
    
    function updateChoicesWithScore() {
        // Calculate the weights based on scores for the wheel
        for(let choice of choices) {
			choice.weight= Math.max(calculateTotalScore(choice.id), 0);
		}
		saveChoices();
		refreshInputs();
    }

    function totalWeight(items = choices) {
      return items.reduce((acc, c) => acc + Number(c.weight), 0);
    }

    // --- Interface & Drawing ---
    function refreshInputs() {
      inputs.innerHTML = "";
      const totalW = totalWeight(choices);

      choices.forEach((c, i) => {
        const row = document.createElement("div");
        const currentWeight = choices.find(wc => wc.id === c.id).weight;

        // Simplification: input is now the base weight (c.weight)
        // Percentage is calculated based on the resulting wheel weight (currentWeight)
        row.innerHTML = `
          <input type="color" value="${c.color}">
          <input type="text" value="${c.label}" placeholder="Nom">
          <input type="number" value="${c.weight}" min="0" style="width:60px;">
          <span style="width:60px;">${((currentWeight / totalW) * 100).toFixed(1)}%</span>
          <button>‚ùå</button>
        `;
        const [color, label, weightInput, , del] = row.children;
        color.addEventListener("input", () => { c.color = color.value; drawWheel(); saveChoices(); });
        label.addEventListener("input", () => { c.label = label.value; saveChoices(); });
        // weightInput now modifies c.weight
        weightInput.addEventListener("input", () => { 
            c.weight = +weightInput.value; 
            drawWheel(); 
            saveChoices(); 
            refreshInputs(); // to update the display of the new weight/percentage
        });
        del.addEventListener("click", () => { 
            // Also clean up votes for this choice
            choices.splice(i, 1); 
            for (const p in participantVotes) {
                delete participantVotes[p][c.id];
            }
            refreshInputs(); 
            drawWheel(); 
            saveChoices();
            saveParticipantVotes();
        });
        inputs.appendChild(row);
      });
    }

    function drawWheel() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const total = totalWeight(choices);
      let start = 0;
      choices.forEach(c => {
		if(!c.weight || c.weight<0) return;
        const angle = (c.weight / total) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(250, 250);
        ctx.fillStyle = c.color;
        ctx.arc(250, 250, 240, start, start + angle);
        ctx.fill();
        // Label
        const mid = start + angle / 2;
        ctx.save();
        ctx.translate(250, 250);
        ctx.rotate(mid);
        ctx.textAlign = "right";
        ctx.fillStyle = "#fff";
        ctx.font = "bold 14px Poppins";
        ctx.fillText(c.label, 230, 0);
        ctx.restore();
        start += angle;
      });
    }

    function findWinner(angle) {
      let acc = 0;
      const total = totalWeight(choices);
      for (let c of choices) {
        acc += (c.weight / total) * Math.PI * 2;
        if (angle % (2 * Math.PI) < acc) return c.label;
      }
      return "";
    }
    
    // --- Voting Modal Functions ---

    function showModal() {
        modalOverlay.style.display = "flex";
    }

    function hideModal() {
        modalOverlay.style.display = "none";
        // Final refresh after voting
        refreshInputs();
        drawWheel();
    }
    
    function renderConfigModal() {
        winner.classList.remove("show");
        modalTitle.textContent = "üëâ Configuration des votes";
        
        modalBody.innerHTML = `
            <div id="vote-config-content">
                <label>Nombre de votes par participant: 
                    <input type="number" id="votesPerParticipant" min="1" value="${votesPerParticipant}">
                </label>
            </div>
        `;
        modalFooter.innerHTML = `
            <button id="start-config">Suivant</button>
        `;
        
        document.getElementById("start-config").addEventListener("click", () => {
            votesPerParticipant = Number(document.getElementById("votesPerParticipant").value);
            if (votesPerParticipant < 1) {
                document.getElementById("votesPerParticipant").value = 1;
                winner.textContent = "‚ö† Au moins 1 participant requis !";
                winner.classList.add("show");
                return;
            }
			
			saveConfig();
            currentParticipant = 1;
            participantVotes = {}; // Start with a blank slate
            
            renderParticipantModal();
        });
        
        showModal();
    }
    
    function renderParticipantModal() {
        modalTitle.textContent = `üëâ Participant n¬∞${currentParticipant}`;
        
        // Calculate current participant's vote count
        const currentVotes = (participantVotes[currentParticipant] ??= {});
        const totalVotesUsed = Object.values(currentVotes).reduce((sum, score) => sum + Math.abs(score), 0);
        const remainingVotes = votesPerParticipant - totalVotesUsed;
        
        // Header for vote count
        modalBody.innerHTML = `
            <p class="vote-info">Votes restants: 
                <span style="font-weight: bold; color: ${remainingVotes < 0 ? 'var(--accent)' : 'var(--text-color)'};">
                    ${remainingVotes} / ${votesPerParticipant}
                </span>
            </p>
            <div id="plat-vote-list"></div>
            <p class="vote-info" id="vote-limit-message" style="color: var(--accent); opacity: 0; transition: opacity 0.3s;">
                Limite de votes atteinte!
            </p>
        `;

        const platVoteList = document.getElementById("plat-vote-list");
        
        choices.forEach((c,index) => {
            const score = currentVotes[c.id] || 0;
            const item = document.createElement("div");
            item.className = "plat-vote-item";
			item.style['border-color'] = c.color;
            item.innerHTML = `
                <span>${c.label || 'Sans nom'}</span>
                <div class="vote-controls">
                    <button id="minus-${index}" class="${remainingVotes <= 0 && score <= 0 ? 'limit' : ''}">‚ûñ</button>
					<span>${score}</span>
                    <button id="plus-${index}" class="${remainingVotes <= 0 && score >= 0 ? 'limit' : ''}">‚ûï</button>
                </div>
            `;
            platVoteList.appendChild(item);
            
            // Event listeners
            item.querySelector(`#plus-${index}`).addEventListener("click", () => handleVote(c.id, 1));
            item.querySelector(`#minus-${index}`).addEventListener("click", () => handleVote(c.id, -1));
        });

        // Footer buttons
        modalFooter.innerHTML = `<button id="finish-vote">Terminer</button><button id="next-participant">Suivant</button>`;
        
		document.getElementById("next-participant").addEventListener("click", () => {
			currentParticipant++;
			participantVotes[currentParticipant] = {}; // Start with a blank slate
			renderParticipantModal();
		});

        
        document.getElementById("finish-vote").addEventListener("click", () => {
			updateChoicesWithScore();
            hideModal();
        });
        
    }

    function handleVote(choiceId, change) {
        const currentVotes = participantVotes[currentParticipant] || {};
        const message = document.getElementById("vote-limit-message");
        
        // Tentative update score
        const newScore = (currentVotes[choiceId] || 0) + change;
        
        // Calculate all votes used *before* the change, then check if the new vote is allowed
        const totalVotesUsed = Object.values(currentVotes).reduce((sum, score) => sum + Math.abs(score), 0);
        const votesUsedIfApplied = totalVotesUsed - Math.abs(currentVotes[choiceId] || 0) + Math.abs(newScore);

        // Check if the participant exceeded their limit (only if adding a vote)
        if (votesUsedIfApplied > votesPerParticipant) {
            // Revert the vote by doing nothing
            message.style.opacity = 1;
            setTimeout(() => message.style.opacity = 0, 1500);
        } else if (newScore < -votesPerParticipant) {
             // Block extreme negative votes to keep the score display clean and meaningful
             message.textContent = "‚ö† Limite de votes n√©gatifs atteinte!";
             message.style.opacity = 1;
             setTimeout(() => {
                message.style.opacity = 0;
                message.textContent = "Limite de votes atteinte!"; // Reset message
             }, 1500);
        } else {
            // Apply the vote
            currentVotes[choiceId] = newScore;
            participantVotes[currentParticipant] = currentVotes;
            
            // Re-render the participant modal to update scores and remaining votes
            renderParticipantModal(); 
        }
    }


    // --- Event Listeners & Init ---

    startBtn.addEventListener("click", () => {
      if (choices.length === 0) {
        winner.textContent = "‚ö† Ajoute au moins un choix !";
        winner.classList.add("show");
        return;
      }
      
      winner.classList.remove("show");
      
      // Use the choices with calculated weights
      const total = totalWeight(choices);
      
      // Select a weighted random choice
      let randomValue = Math.random() * total;
      let targetAngle = 0;
      let accWeight = 0;
      let winnerFound = false;
      
      for (let c of choices) {
          accWeight += c.weight;
          if (randomValue <= accWeight) {
              const segmentAngle = (c.weight / total) * Math.PI * 2;
              const startAngleRad = ((accWeight - c.weight) / total) * Math.PI * 2;
              
              // Angle within the segment: ensures landing inside the segment
              targetAngle = startAngleRad + Math.random() * segmentAngle;
              winnerFound = true;
              break;
          }
      }
      
      if (!winnerFound) targetAngle = Math.random() * Math.PI * 2; // Fallback
      
      const spinTime = duration.value * 1000;
      const tours = nbTour.value * 2 * Math.PI;
      
      // Final rotation angle correction to align the target angle with the pointer (3 * PI / 2)
      const rotationCorrection = (3 * Math.PI / 2) - (targetAngle % (2 * Math.PI));
      const finalRotationAngle = rotationCorrection + tours;
      
      // Reset position instantly
      canvas.style.transition = "transform 0s";
      // We take the remainder of the last angle to start the spin from the visible position
      canvas.style.transform = `rotate(${lastAngle % (2 * Math.PI)}rad)`;

      setTimeout(() => {
        // Apply spinning transition
        canvas.style.transition = `transform ${spinTime}ms cubic-bezier(0.2, 0.8, 0.2, 1)`;
        canvas.style.transform = `rotate(${finalRotationAngle}rad)`;
      }, 50);

      setTimeout(() => {
        // The winner is determined by the target angle that was calculated
        const checkAngle = (targetAngle) % (2 * Math.PI); 
        const w = findWinner(checkAngle);
        winner.textContent = `üèÜ ${w || "Personne"} !`;
        winner.classList.add("show");
        
        // Save the final angle so the next spin starts from there
        lastAngle = finalRotationAngle;
        
      }, spinTime);
    });

    addBtn.addEventListener("click", () => {
      // Use weight for the input value
      choices.push({ id: Date.now() + Math.random(), label: "", color: randomColor(), weight: 1 });
      refreshInputs();
      drawWheel();
      saveChoices();
    });
	
	document.querySelector("#modal-close").addEventListener("click", () => {
      hideModal();
    });
    
    startVoteBtn.addEventListener("click", () => {
        if (choices.length === 0) {
            winner.textContent = "‚ö† Ajoute au moins un plat pour pouvoir voter !";
            winner.classList.add("show");
            return;
        }
        renderConfigModal();
    });
    
    // Save settings when they change
    duration.addEventListener("input", saveConfig);
    nbTour.addEventListener("input", saveConfig);


    // Init
    loadConfig();
    choices = loadChoices();
    refreshInputs();
    drawWheel();
  </script>
</body>
</html>
